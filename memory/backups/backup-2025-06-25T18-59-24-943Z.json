{
  "timestamp": "2025-06-25T18:59:24.943Z",
  "version": "1.0",
  "entries": [
    {
      "id": "entry_mcbcslqv_8gj7yxidk",
      "key": "demo_routes_analysis",
      "value": "{\"overview\":\"Demo routes provide 4 public endpoints for travel search and price analysis with mock AI-powered insights\",\"endpoints\":{\"POST /api/v1/demo/chat\":{\"purpose\":\"Conversational interface with mock travel insights\",\"features\":[\"Session management\",\"Demo conversation matching\",\"Contextual suggestions\",\"No auth required\"],\"validation\":\"Zod schema for message (1-500 chars) and optional sessionId\"},\"POST /api/v1/demo/analyze-price\":{\"purpose\":\"Analyze flight prices with historical context\",\"features\":[\"Price statistics\",\"Historical comparison\",\"Buy/wait recommendations\",\"Alternative suggestions\"],\"validation\":\"FlightResultSchema with strict airport codes, dates, and positive prices\"},\"GET /api/v1/demo/routes\":{\"purpose\":\"Get available demo routes with current insights\",\"features\":[\"Seasonal pricing data\",\"Trending destinations\",\"Popularity scores\"],\"validation\":\"None (GET endpoint)\"},\"POST /api/v1/demo/quick-search\":{\"purpose\":\"Quick flight search with instant insights\",\"features\":[\"Dynamic pricing based on booking window\",\"Multiple flight options\",\"Price monitoring offers\"],\"validation\":\"Basic schema for origin, destination, dates\"}},\"key_patterns\":[\"All endpoints are public (no authentication) for demo purposes\",\"Uses Zod for input validation with sanitization middleware\",\"Simulates processing delays (800-1200ms) for realistic UX\",\"Generates mock data based on realistic pricing patterns\",\"Provides actionable insights and recommendations\"],\"dependencies\":[\"express\",\"zod\",\"uuid\",\"custom middleware for sanitization\"]}",
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T02:46:56.023Z",
      "updatedAt": "2025-06-25T02:46:56.023Z",
      "lastAccessedAt": "2025-06-25T05:17:39.128Z",
      "version": 1,
      "size": 1679,
      "compressed": true,
      "checksum": "e111330ead709a9c32cd3bda3e42eda9f824526c9d0ab721cc5c1a73310edd0f",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbctdvn_4j85zhgji",
      "key": "ai_services_analysis",
      "value": "{\"overview\":\"Travel prompts module provides AI system prompts, mock data patterns, and intelligent price analysis functions\",\"components\":{\"TRAVEL_AGENT_SYSTEM_PROMPT\":{\"purpose\":\"Claude AI system prompt for travel agent persona\",\"capabilities\":[\"Flight search analysis and extraction\",\"Historical price context\",\"Personalized recommendations\",\"Deal identification\",\"Alternative suggestions\"],\"style\":\"Conversational, actionable, data-driven with specific numbers\"},\"DEMO_CONVERSATIONS\":{\"purpose\":\"Pre-defined conversation examples for quick demo value\",\"examples\":[\"Tokyo in April query\",\"Specific date range follow-up\"],\"features\":\"Emojis, specific prices, actionable insights, monitoring offers\"},\"MOCK_PRICE_PATTERNS\":{\"purpose\":\"Realistic pricing data for demo without external APIs\",\"routes\":[\"YYZ-NRT (Toronto-Tokyo)\",\"YYZ-LHR (Toronto-London)\"],\"data_structure\":{\"seasonal\":\"Monthly average/low/high prices\",\"bookingCurve\":\"Price multipliers by days until departure\",\"insights\":\"Route-specific tips and recommendations\"}},\"Functions\":{\"generatePriceInsight\":{\"purpose\":\"Generate natural language price analysis\",\"logic\":\"Compares current price to seasonal average with booking curve\",\"outputs\":[\"Excellent deal (<-15%)\",\"Good price (-5 to -15%)\",\"Fair price (-5 to +5%)\",\"Above average (>+5%)\"]},\"generateMockPriceHistory\":{\"purpose\":\"Create realistic 90-day price history\",\"features\":[\"Booking curve simulation\",\"Day-of-week variations\",\"Event markers\",\"Seasonal adjustments\"]}}},\"design_patterns\":[\"Mock data approach for demo without API dependencies\",\"Realistic pricing algorithms based on industry patterns\",\"Emoji usage for visual engagement\",\"Specific percentages and dollar amounts for credibility\",\"Actionable recommendations at every step\"],\"integration_approach\":\"Imported and used by demo routes for all AI-powered insights\"}",
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T02:47:32.483Z",
      "updatedAt": "2025-06-25T02:47:32.483Z",
      "lastAccessedAt": "2025-06-25T05:17:39.128Z",
      "version": 1,
      "size": 2000,
      "compressed": true,
      "checksum": "edca6c6d96a5e388aadf9fb93fa53fe3974db4205372032e27807ef3804b3b61",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbcw82g_8lwzohfpd",
      "key": "architecture_analysis",
      "value": {
        "overview": "Modular Express.js architecture with TypeScript, Zod validation, and middleware-based security",
        "patterns": {
          "routing": {
            "pattern": "Modular router pattern",
            "structure": "Each feature has its own router file in routes/",
            "mounting": "Routes mounted on app instance with version prefix /api/v1"
          },
          "validation": {
            "pattern": "Schema-based validation with Zod",
            "implementation": "Schemas defined per endpoint, validated via sanitizeInputs middleware",
            "benefits": "Type-safe, declarative validation with automatic error handling"
          },
          "middleware_stack": {
            "order": [
              "Request ID generation",
              "Security (Helmet)",
              "CORS",
              "Body parsing",
              "Compression",
              "Logging (Morgan)",
              "Session management",
              "Request logging",
              "Rate limiting",
              "Input sanitization",
              "Audit logging (for sensitive routes)"
            ],
            "pattern": "Layered security and processing pipeline"
          },
          "error_handling": {
            "pattern": "Centralized error handling",
            "components": [
              "AppError class",
              "ErrorCodes enum",
              "Global error handler middleware"
            ]
          },
          "ai_integration": {
            "pattern": "Service module pattern",
            "structure": "AI logic encapsulated in services/ai/",
            "approach": "Mock data for demo, easily swappable with real AI calls"
          }
        },
        "design_decisions": [
          "TypeScript for type safety across the stack",
          "Zod for runtime validation matching TypeScript types",
          "DOMPurify for XSS protection in sanitization",
          "Comprehensive input sanitization with injection protection",
          "Feature flags for demo mode and email notifications",
          "Mock data approach allows testing without external dependencies",
          "Session-based authentication ready",
          "Structured logging with Winston",
          "Health checks and metrics endpoints for monitoring"
        ],
        "strengths": [
          "Strong security posture with multiple defense layers",
          "Type safety from validation to business logic",
          "Clean separation of concerns",
          "Production-ready middleware stack",
          "Easy to extend with new features"
        ],
        "considerations": [
          "Demo routes not yet mounted in server.ts",
          "No database integration visible yet",
          "Authentication routes exist but implementation not shown",
          "Real AI integration will need API key management"
        ]
      },
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T02:49:44.920Z",
      "updatedAt": "2025-06-25T02:49:44.920Z",
      "lastAccessedAt": "2025-06-25T17:54:07.037Z",
      "version": 1,
      "size": 2211,
      "compressed": true,
      "checksum": "bbf0a11ad5d40bfee93c1a688249b3b8a1890c84289b73ac179cc3040daa80eb",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbcwxxx_vx70zeouc",
      "key": "integration_points",
      "value": "{\"status\":\"Demo routes created but NOT integrated\",\"missing_integrations\":[\"Demo routes not imported in server.ts\",\"Demo routes not mounted on Express app\",\"No database models for storing conversations or price data\",\"No actual AI service integration (using mock data)\"],\"existing_integrations\":{\"middleware\":{\"sanitizeInputs\":\"Used correctly with Zod schemas\",\"imports\":\"Proper path aliases (@/) configured\"},\"shared_utilities\":{\"uuid\":\"Using v4 for session and ID generation\",\"error_handling\":\"Would integrate with existing AppError system\",\"logging\":\"Ready to use existing logger utility\"},\"api_structure\":{\"pattern\":\"Follows /api/v1/{feature} convention\",\"response_format\":\"Consistent {success, data} structure\"}},\"required_integrations\":[{\"task\":\"Import demo routes in server.ts\",\"code\":\"import demoRoutes from './routes/demo';\",\"location\":\"server.ts:135\"},{\"task\":\"Mount demo routes on app\",\"code\":\"app.use('/api/v1/demo', demoRoutes);\",\"location\":\"server.ts:141\"},{\"task\":\"Add demo feature flag check\",\"code\":\"if (env.FEATURE_DEMO_MODE) { app.use('/api/v1/demo', demoRoutes); }\",\"consideration\":\"Only enable demo routes when feature flag is on\"}],\"future_integrations\":[\"Replace mock AI responses with actual Claude API calls\",\"Add database persistence for conversations\",\"Integrate with real flight search APIs\",\"Add authentication for non-demo endpoints\",\"Connect to payment system for premium features\"],\"compatibility\":{\"typescript\":\"Fully compatible with existing TS setup\",\"validation\":\"Uses same Zod patterns as other routes\",\"security\":\"Leverages existing sanitization middleware\",\"monitoring\":\"Would automatically benefit from request logging\"}}",
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T02:50:18.453Z",
      "updatedAt": "2025-06-25T02:50:18.453Z",
      "lastAccessedAt": "2025-06-25T05:17:39.128Z",
      "version": 1,
      "size": 1809,
      "compressed": true,
      "checksum": "33e0a45a725b4b885a68d404ef80904a7a4ed04ae087e8162a90400c5c710186",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbeg4p6_swo8aic8j",
      "key": "typescript_best_practices",
      "value": "Key TypeScript learnings from travel agent project:\n1. ALWAYS check for undefined/null before accessing properties (use optional chaining ?. or guards)\n2. When defining object types with varying structures, use union types or ensure all properties exist\n3. Array access requires bounds checking - use array.length > index before array[index]\n4. Type narrowing with 'in' operator for conditional properties (e.g., 'bookingCurve' in patterns)\n5. Explicit type assertions needed when TypeScript cannot infer types (use 'as' carefully)\n6. Consistent object structures prevent type errors - all MOCK_PRICE_PATTERNS entries should have same shape\n7. Use strict null checks to catch potential runtime errors at compile time\n8. Define explicit return types for functions to catch type mismatches early",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T03:33:13.290Z",
      "updatedAt": "2025-06-25T03:33:13.290Z",
      "lastAccessedAt": "2025-06-25T05:17:39.128Z",
      "version": 1,
      "size": 832,
      "compressed": false,
      "checksum": "5c0cf6ac9de38e550e708c6076eada1c39f372dc074de827f388ae33f79c5752",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbgiqjy_y6un03zjv",
      "key": "demo_implementation_complete",
      "value": "Demo API implementation completed successfully with 4 endpoints, comprehensive tests, and AI prompt integration. All TypeScript errors resolved using swarm coordination and stored best practices. Ready for production deployment.",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T04:31:14.158Z",
      "updatedAt": "2025-06-25T04:31:14.158Z",
      "lastAccessedAt": "2025-06-25T05:17:39.128Z",
      "version": 1,
      "size": 259,
      "compressed": false,
      "checksum": "8ff9e67ba99285affe98b7efb50c9cc949f9e40d8c9f9c003227c850a7e4ab44",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbi2q0l_rnen3oef8",
      "key": "user_data_schemas",
      "value": "# 📊 Data Schemas & File Organization\n## Agentic Travel Agent MVP\n\n**Senior Data Engineering Standards**  \n**Purpose**: Consistent data structures and atomic file operations  \n**MVP Strategy**: Single JSON file per user with PostgreSQL migration path  \n**Updated**: June 23, 2025\n\n---\n\n## 🎯 Data Architecture Principles\n\n### MVP File-based Storage\n1. **Single JSON per User**: `user-{uuid}.json` containing complete user state\n2. **Atomic Operations**: Write to temp file, then rename for atomicity\n3. **Schema Validation**: Zod schemas validate all data operations\n4. **Migration Ready**: Designed for seamless PostgreSQL transition\n5. **Consistent Naming**: UUID-based identifiers throughout\n\n### File Naming Conventions\n```typescript\n// User data files\nconst userFileName = (userId: string) => `user-${userId}.json`;\n// Example: user-123e4567-e89b-12d3-a456-426614174000.json\n\n// System configuration files\nconst systemFiles = {\n  config: 'system-config.json',\n  demoData: 'demo-data.json',\n  apiCache: 'api-cache.json'\n};\n\n// Temporary files for atomic operations\nconst tempFileName = (operation: string) => \n  `temp-${Date.now()}-${operation}.json`;\n// Example: temp-1719158422123-user-update.json\n```\n\n---\n\n## 📝 Core Data Schemas\n\n### User Profile Schema\n```typescript\nimport { z } from 'zod';\n\n// Currency codes enum\nexport const CurrencyCodeSchema = z.enum(['CAD', 'USD', 'EUR', 'GBP', 'JPY', 'AUD']);\nexport type CurrencyCode = z.infer<typeof CurrencyCodeSchema>;\n\n// Communication frequency enum\nexport const CommunicationFrequencySchema = z.enum(['immediate', 'daily', 'weekly']);\nexport type CommunicationFrequency = z.infer<typeof CommunicationFrequencySchema>;\n\n// User preferences schema\nexport const UserPreferencesSchema = z.object({\n  currency: CurrencyCodeSchema.default('CAD'),\n  timezone: z.string().min(1), // IANA timezone (e.g., \"America/Toronto\")\n  preferredDepartureAirport: z.string().length(3).regex(/^[A-Z]{3}$/), // IATA code\n  communicationFrequency: CommunicationFrequencySchema.default('daily')\n});\n\nexport type UserPreferences = z.infer<typeof UserPreferencesSchema>;\n\n// Main user profile schema\nexport const UserProfileSchema = z.object({\n  id: z.string().uuid(),\n  firstName: z.string().min(1).max(50),\n  lastName: z.string().min(1).max(50),\n  email: z.string().email(),\n  preferences: UserPreferencesSchema,\n  activeSearches: z.array(z.string().uuid()).default([]), // Flight search IDs\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n  version: z.number().int().positive().default(1) // For optimistic locking\n});\n\nexport type UserProfile = z.infer<typeof UserProfileSchema>;\n```\n\n### Flight Search Schema\n```typescript\n// Travel class enum\nexport const TravelClassSchema = z.enum(['economy', 'premium-economy', 'business', 'first']);\nexport type TravelClass = z.infer<typeof TravelClassSchema>;\n\n// Search status enum\nexport const SearchStatusSchema = z.enum(['active', 'paused', 'completed', 'expired']);\nexport type SearchStatus = z.infer<typeof SearchStatusSchema>;\n\n// Passenger information\nexport const PassengerInfoSchema = z.object({\n  adults: z.number().int().min(1).max(9),\n  children: z.number().int().min(0).max(8),\n  infants: z.number().int().min(0).max(2)\n}).refine(data => data.infants <= data.adults, {\n  message: \"Number of infants cannot exceed number of adults\",\n  path: [\"infants\"]\n});\n\nexport type PassengerInfo = z.infer<typeof PassengerInfoSchema>;\n\n// Flight search criteria\nexport const FlightSearchCriteriaSchema = z.object({\n  origin: z.string().length(3).regex(/^[A-Z]{3}$/), // IATA airport code\n  destination: z.string().length(3).regex(/^[A-Z]{3}$/), // IATA airport code\n  departureDate: z.string().datetime(),\n  returnDate: z.string().datetime().optional(),\n  passengers: PassengerInfoSchema,\n  travelClass: TravelClassSchema.default('economy'),\n  maxPrice: z.number().positive().max(50000),\n  currency: CurrencyCodeSchema,\n  nonStop: z.boolean().default(false),\n  includedAirlines: z.array(z.string().length(2)).optional(), // IATA airline codes\n  excludedAirlines: z.array(z.string().length(2)).optional() // IATA airline codes\n});\n\nexport type FlightSearchCriteria = z.infer<typeof FlightSearchCriteriaSchema>;\n\n// Price data point for history tracking\nexport const PriceDataPointSchema = z.object({\n  price: z.number().positive(),\n  currency: CurrencyCodeSchema,\n  recordedAt: z.string().datetime(),\n  source: z.enum(['amadeus', 'manual', 'demo']).default('amadeus'),\n  flightDetails: z.object({\n    airline: z.string().optional(),\n    flightNumber: z.string().optional(),\n    duration: z.string().optional(), // ISO 8601 duration\n    stops: z.number().int().min(0).default(0),\n    departureTime: z.string().datetime().optional(),\n    arrivalTime: z.string().datetime().optional()\n  }).optional()\n});\n\nexport type PriceDataPoint = z.infer<typeof PriceDataPointSchema>;\n\n// Flight search entity\nexport const FlightSearchSchema = z.object({\n  id: z.string().uuid(),\n  userId: z.string().uuid(),\n  criteria: FlightSearchCriteriaSchema,\n  status: SearchStatusSchema.default('active'),\n  lastChecked: z.string().datetime().optional(),\n  nextCheck: z.string().datetime().optional(),\n  bestPriceFound: z.object({\n    price: z.number().positive(),\n    currency: CurrencyCodeSchema,\n    foundAt: z.string().datetime(),\n    flightDetails: z.object({\n      id: z.string(),\n      airline: z.string(),\n      flightNumber: z.string(),\n      duration: z.string(),\n      stops: z.number().int().min(0),\n      departureTime: z.string().datetime(),\n      arrivalTime: z.string().datetime(),\n      bookingUrl: z.string().url().optional()\n    })\n  }).optional(),\n  priceHistory: z.array(PriceDataPointSchema).default([]),\n  alertsSent: z.number().int().min(0).default(0),\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n  version: z.number().int().positive().default(1)\n});\n\nexport type FlightSearch = z.infer<typeof FlightSearchSchema>;\n```\n\n### Complete User Data File Schema\n```typescript\n// The main data structure stored in user-{uuid}.json\nexport const UserDataFileSchema = z.object({\n  profile: UserProfileSchema,\n  searches: z.array(FlightSearchSchema).default([]),\n  conversationHistory: z.array(z.object({\n    id: z.string().uuid(),\n    timestamp: z.string().datetime(),\n    role: z.enum(['user', 'assistant']),\n    content: z.string(),\n    metadata: z.record(z.unknown()).optional()\n  })).default([]),\n  systemMetadata: z.object({\n    fileVersion: z.string().default('1.0.0'),\n    lastModified: z.string().datetime(),\n    checksumMD5: z.string().optional(), // For data integrity\n    backupCount: z.number().int().min(0).default(0)\n  })\n});\n\nexport type UserDataFile = z.infer<typeof UserDataFileSchema>;\n```\n\n---\n\n## 🔧 System Configuration Schemas\n\n### Application Configuration\n```typescript\n// System configuration schema\nexport const SystemConfigSchema = z.object({\n  application: z.object({\n    name: z.string().default('Agentic Travel Agent'),\n    version: z.string().default('1.0.0'),\n    environment: z.enum(['development', 'staging', 'production']).default('development'),\n    features: z.object({\n      demoMode: z.boolean().default(true),\n      priceProjections: z.boolean().default(false),\n      multiCurrency: z.boolean().default(true),\n      emailNotifications: z.boolean().default(true)\n    })\n  }),\n  apis: z.object({\n    amadeus: z.object({\n      environment: z.enum(['test', 'production']).default('test'),\n      rateLimit: z.object({\n        requestsPerMinute: z.number().int().positive().default(100),\n        dailyQuota: z.number().int().positive().default(1000)\n      })\n    }),\n    anthropic: z.object({\n      model: z.string().default('claude-opus-4'),\n      maxTokens: z.number().int().positive().default(4096),\n      temperature: z.number().min(0).max(1).default(0.7)\n    }),\n    sendgrid: z.object({\n      environment: z.enum(['sandbox', 'production']).default('sandbox'),\n      templateIds: z.object({\n        priceAlert: z.string().optional(),\n        welcome: z.string().optional(),\n        searchSummary: z.string().optional()\n      })\n    })\n  }),\n  monitoring: z.object({\n    priceCheckInterval: z.number().int().positive().default(86400000), // 24 hours in ms\n    maxActiveSearchesPerUser: z.number().int().positive().default(5),\n    dataRetentionDays: z.number().int().positive().default(90)\n  })\n});\n\nexport type SystemConfig = z.infer<typeof SystemConfigSchema>;\n```\n\n### Demo Data Schema\n```typescript\n// Demo data for testing and development\nexport const DemoDataSchema = z.object({\n  users: z.array(UserProfileSchema),\n  flightOffers: z.array(z.object({\n    id: z.string(),\n    origin: z.string().length(3),\n    destination: z.string().length(3),\n    departureDate: z.string().datetime(),\n    price: z.number().positive(),\n    currency: CurrencyCodeSchema,\n    airline: z.string(),\n    duration: z.string(),\n    stops: z.number().int().min(0)\n  })),\n  priceHistory: z.array(z.object({\n    route: z.string(), // \"YYZ-NRT\"\n    date: z.string().datetime(),\n    price: z.number().positive(),\n    currency: CurrencyCodeSchema\n  })),\n  metadata: z.object({\n    generatedAt: z.string().datetime(),\n    version: z.string(),\n    description: z.string()\n  })\n});\n\nexport type DemoData = z.infer<typeof DemoDataSchema>;\n```\n\n---\n\n## 🗃️ File Operations & Data Access\n\n### Atomic File Operations\n```typescript\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { randomUUID } from 'crypto';\n\nexport class UserDataManager {\n  private readonly dataDirectory: string;\n\n  constructor(dataDirectory: string = './data/users') {\n    this.dataDirectory = dataDirectory;\n  }\n\n  // Read user data with validation\n  async readUserData(userId: string): Promise<UserDataFile | null> {\n    try {\n      const filePath = join(this.dataDirectory, `user-${userId}.json`);\n      const rawData = await fs.readFile(filePath, 'utf-8');\n      const parsedData = JSON.parse(rawData);\n      \n      // Validate schema\n      const validatedData = UserDataFileSchema.parse(parsedData);\n      return validatedData;\n    } catch (error) {\n      if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\n        return null; // File doesn't exist\n      }\n      throw error;\n    }\n  }\n\n  // Atomic write operation\n  async writeUserData(userId: string, userData: UserDataFile): Promise<void> {\n    // Validate data before writing\n    const validatedData = UserDataFileSchema.parse(userData);\n    \n    // Update system metadata\n    validatedData.systemMetadata.lastModified = new Date().toISOString();\n    \n    const finalPath = join(this.dataDirectory, `user-${userId}.json`);\n    const tempPath = join(this.dataDirectory, `temp-${Date.now()}-${randomUUID()}.json`);\n    \n    try {\n      // Write to temporary file first\n      await fs.writeFile(tempPath, JSON.stringify(validatedData, null, 2), 'utf-8');\n      \n      // Atomic rename (POSIX systems guarantee atomicity)\n      await fs.rename(tempPath, finalPath);\n    } catch (error) {\n      // Cleanup temp file if it exists\n      try {\n        await fs.unlink(tempPath);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw error;\n    }\n  }\n\n  // Create new user with default data\n  async createUser(userProfile: UserProfile): Promise<UserDataFile> {\n    const userData: UserDataFile = {\n      profile: userProfile,\n      searches: [],\n      conversationHistory: [],\n      systemMetadata: {\n        fileVersion: '1.0.0',\n        lastModified: new Date().toISOString(),\n        backupCount: 0\n      }\n    };\n\n    await this.writeUserData(userProfile.id, userData);\n    return userData;\n  }\n\n  // Update user data with optimistic locking\n  async updateUserData(\n    userId: string, \n    updateFn: (userData: UserDataFile) => UserDataFile\n  ): Promise<UserDataFile> {\n    const currentData = await this.readUserData(userId);\n    if (!currentData) {\n      throw new Error(`User ${userId} not found`);\n    }\n\n    const updatedData = updateFn(currentData);\n    \n    // Increment version for optimistic locking\n    updatedData.profile.version = currentData.profile.version + 1;\n    updatedData.profile.updatedAt = new Date().toISOString();\n\n    await this.writeUserData(userId, updatedData);\n    return updatedData;\n  }\n\n  // Add flight search to user\n  async addFlightSearch(userId: string, searchCriteria: FlightSearchCriteria): Promise<FlightSearch> {\n    const newSearch: FlightSearch = {\n      id: randomUUID(),\n      userId,\n      criteria: searchCriteria,\n      status: 'active',\n      priceHistory: [],\n      alertsSent: 0,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      version: 1\n    };\n\n    await this.updateUserData(userId, (userData) => {\n      userData.searches.push(newSearch);\n      userData.profile.activeSearches.push(newSearch.id);\n      return userData;\n    });\n\n    return newSearch;\n  }\n\n  // Update flight search\n  async updateFlightSearch(\n    userId: string, \n    searchId: string, \n    updates: Partial<FlightSearch>\n  ): Promise<FlightSearch> {\n    let updatedSearch: FlightSearch | undefined;\n\n    await this.updateUserData(userId, (userData) => {\n      const searchIndex = userData.searches.findIndex(s => s.id === searchId);\n      if (searchIndex === -1) {\n        throw new Error(`Search ${searchId} not found for user ${userId}`);\n      }\n\n      updatedSearch = {\n        ...userData.searches[searchIndex],\n        ...updates,\n        updatedAt: new Date().toISOString(),\n        version: userData.searches[searchIndex].version + 1\n      };\n\n      userData.searches[searchIndex] = updatedSearch;\n      return userData;\n    });\n\n    return updatedSearch!;\n  }\n}\n```\n\n### Data Validation Utilities\n```typescript\n// Validation helpers\nexport const ValidationUtils = {\n  // Validate IATA airport code\n  isValidIATACode: (code: string): boolean => {\n    return /^[A-Z]{3}$/.test(code);\n  },\n\n  // Validate airline code\n  isValidAirlineCode: (code: string): boolean => {\n    return /^[A-Z0-9]{2}$/.test(code);\n  },\n\n  // Validate currency code\n  isValidCurrencyCode: (code: string): boolean => {\n    return CurrencyCodeSchema.safeParse(code).success;\n  },\n\n  // Validate date is in future\n  isFutureDate: (dateString: string): boolean => {\n    const date = new Date(dateString);\n    return date > new Date();\n  },\n\n  // Validate passenger combination\n  isValidPassengerCombination: (passengers: PassengerInfo): boolean => {\n    return PassengerInfoSchema.safeParse(passengers).success;\n  }\n};\n```\n\n---\n\n## 📊 Migration Planning (File → PostgreSQL)\n\n### PostgreSQL Schema Design\n```sql\n-- Future PostgreSQL schema (for reference)\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Users table\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  first_name VARCHAR(50) NOT NULL,\n  last_name VARCHAR(50) NOT NULL,\n  email VARCHAR(255) UNIQUE NOT NULL,\n  preferences JSONB NOT NULL DEFAULT '{}',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  version INTEGER DEFAULT 1\n);\n\n-- Flight searches table\nCREATE TABLE flight_searches (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  criteria JSONB NOT NULL,\n  status VARCHAR(20) DEFAULT 'active',\n  last_checked TIMESTAMP WITH TIME ZONE,\n  next_check TIMESTAMP WITH TIME ZONE,\n  best_price_found JSONB,\n  alerts_sent INTEGER DEFAULT 0,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  version INTEGER DEFAULT 1\n);\n\n-- Price history table\nCREATE TABLE price_history (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  search_id UUID NOT NULL REFERENCES flight_searches(id) ON DELETE CASCADE,\n  price DECIMAL(10,2) NOT NULL,\n  currency VARCHAR(3) NOT NULL,\n  flight_details JSONB,\n  recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  source VARCHAR(20) DEFAULT 'amadeus'\n);\n\n-- Conversation history table\nCREATE TABLE conversation_history (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  role VARCHAR(20) NOT NULL,\n  content TEXT NOT NULL,\n  metadata JSONB,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Indexes for performance\nCREATE INDEX idx_flight_searches_user_id ON flight_searches(user_id);\nCREATE INDEX idx_flight_searches_status ON flight_searches(status);\nCREATE INDEX idx_price_history_search_id ON price_history(search_id);\nCREATE INDEX idx_price_history_recorded_at ON price_history(recorded_at);\nCREATE INDEX idx_conversation_history_user_id ON conversation_history(user_id);\n\n-- Triggers for updated_at\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\nCREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users \n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER update_flight_searches_updated_at BEFORE UPDATE ON flight_searches \n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n```\n\n### Migration Utilities\n```typescript\n// Migration helper (for future use)\nexport class DataMigrator {\n  async migrateFileToDatabase(userId: string): Promise<void> {\n    const fileData = await this.userDataManager.readUserData(userId);\n    if (!fileData) {\n      throw new Error(`No file data found for user ${userId}`);\n    }\n\n    // Begin transaction\n    // Insert user profile\n    // Insert flight searches\n    // Insert price history\n    // Insert conversation history\n    // Commit transaction\n    \n    // Backup original file\n    // Delete original file (optional)\n  }\n\n  async validateMigration(userId: string): Promise<boolean> {\n    // Compare file data with database data\n    // Return true if data matches\n    return true;\n  }\n}\n```\n\n---\n\n**Status**: ✅ Data Schemas Complete  \n**MVP**: Single JSON file per user with atomic operations  \n**Validation**: Zod schemas ensure data integrity  \n**Migration**: PostgreSQL schema designed for seamless transition  \n**Next**: Create implementation roadmap with milestones",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T05:14:46.197Z",
      "updatedAt": "2025-06-25T05:14:46.197Z",
      "lastAccessedAt": "2025-06-25T05:17:39.960Z",
      "version": 1,
      "size": 19307,
      "compressed": true,
      "checksum": "85bb9a33815b08c1eb2fb12def48decf3b72947e964629e262a503c6e4e8bd98",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcbi5e3z_ifqnku2jx",
      "key": "swarm-development-hierarchical-1750828496503/orchestrator/specification",
      "value": {
        "step": "Specification",
        "objective": "Implement complete user data layer",
        "findings": {
          "existingImplementation": true,
          "schemaInconsistencies": true,
          "missingComponents": [
            "custom error classes",
            "validation utilities",
            "conversationHistory",
            "systemMetadata",
            "costTracking"
          ],
          "requiredUpdates": [
            "UserDataManager reconciliation",
            "Schema alignment",
            "Test updates"
          ]
        },
        "strategy": "development",
        "mode": "hierarchical",
        "agents": 5
      },
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T05:16:50.735Z",
      "updatedAt": "2025-06-25T05:16:50.735Z",
      "lastAccessedAt": "2025-06-25T05:17:48.123Z",
      "version": 1,
      "size": 441,
      "compressed": false,
      "checksum": "2c4fcbd67dac109f282241acf3215aaa04a9a4682c8869eeed4f8a863d9a954c",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcc6eggs_cu8a8w667",
      "key": "user_data_layer_complete",
      "value": "User data layer implementation complete. Includes: UserDataManager with atomic file operations, proper locking (proper-lockfile), comprehensive validation utilities, full test coverage (25 passing tests), and schemas based on memory-bank/data-schemas.md specifications. Ready for authentication system integration.",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T16:35:44.476Z",
      "updatedAt": "2025-06-25T16:35:44.476Z",
      "lastAccessedAt": "2025-06-25T16:35:44.476Z",
      "version": 1,
      "size": 345,
      "compressed": false,
      "checksum": "d27cd5963dfc6df9f30a197bc6299cc58359f4fea7a8f6d71c0bce77ad1d2124",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mcc9agcy_mynkycz9y",
      "key": "swarm-testing-distributed-1750874097123/agent3/task-started",
      "value": {
        "step": "Task Started",
        "timestamp": "2025-01-26T00:15:00.000Z",
        "status": "Creating comprehensive tests for password reset and session management"
      },
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T17:56:36.562Z",
      "updatedAt": "2025-06-25T17:56:36.562Z",
      "lastAccessedAt": "2025-06-25T17:56:36.562Z",
      "version": 1,
      "size": 173,
      "compressed": false,
      "checksum": "4a7d73fad9ba96a66fc963c703a75bcecd37d70b5dac8557507b003a41be059b",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mccb4qky_6j7r20kt3",
      "key": "refactor_plan_phase1",
      "value": "Converting AuthService from class-based to functional module. Key steps: 1) Create auth/types.ts with branded types (UserId, SessionId, HashedPassword), 2) Create auth/storage.ts for password operations, 3) Create auth/operations.ts with pure functions for register/login/logout, 4) Create auth/index.ts as public API, 5) Maintain backward compatibility during transition. Result pattern implementation comes in Phase 3.",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T18:48:09.106Z",
      "updatedAt": "2025-06-25T18:48:09.106Z",
      "lastAccessedAt": "2025-06-25T18:55:47.486Z",
      "version": 1,
      "size": 451,
      "compressed": false,
      "checksum": "7ad9090c15edebf681d82da4c019efd37442462e1c9c551bc2655b20a571cab0",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mccb5019_pybs06ll6",
      "key": "auth_current_structure",
      "value": "Current AuthService uses class-based OOP with singleton pattern. Key methods: registerUser, loginUser, logoutUser, validateJWTToken, validateSession. Dependencies: UserDataManager (class), bcrypt, jwt, crypto. Private storage: passwordStorage Map, sessions Map, failedLoginAttempts Map. Tests currently mock private methods storeUserPassword and getUserPasswordHash.",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T18:48:21.357Z",
      "updatedAt": "2025-06-25T18:48:21.357Z",
      "lastAccessedAt": "2025-06-25T18:48:21.357Z",
      "version": 1,
      "size": 397,
      "compressed": false,
      "checksum": "ea2255f99f55f16bf4075adb51e6805fb863d7ba884e8ee9b87148110c9a55d2",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mccb8xof_xq2kxshr2",
      "key": "swarm-development-hierarchical-1750877313672/password-developer/operations",
      "value": "{\"module\":\"src/services/auth/functional/password.ts\",\"description\":\"Pure functional password operations module with bcrypt dependency injection\",\"exports\":{\"types\":[\"HashedPassword\",\"PlainTextPassword\",\"PasswordStrength\",\"BcryptDependency\",\"PasswordConfig\",\"PasswordStorageEntry\",\"PasswordHistoryEntry\"],\"functions\":[\"hashPassword\",\"verifyPassword\",\"validatePassword\",\"isHashedPassword\",\"needsRehash\",\"createPasswordStorage\",\"updatePasswordStorage\",\"wasPasswordPreviouslyUsed\",\"addToPasswordHistory\",\"calculatePasswordStrength\",\"generateSecurePassword\"],\"constants\":[\"defaultPasswordConfig\"],\"factories\":[\"createPasswordHasher\",\"createPasswordVerifier\"]},\"features\":[\"Branded HashedPassword type for type safety\",\"Pure functions with dependency injection\",\"Password validation and strength calculation\",\"Password history tracking\",\"Storage operations\",\"Configurable password requirements\",\"Secure password generation\"],\"dependencies\":{\"bcrypt\":\"injected\",\"crypto\":\"for secure random generation\"},\"configuration\":{\"saltRounds\":12,\"minLength\":8,\"maxLength\":128,\"requireUppercase\":true,\"requireLowercase\":true,\"requireNumbers\":true,\"requireSpecialChars\":true}}",
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T18:51:24.927Z",
      "updatedAt": "2025-06-25T18:51:24.927Z",
      "lastAccessedAt": "2025-06-25T18:51:24.927Z",
      "version": 1,
      "size": 1289,
      "compressed": true,
      "checksum": "9dc52b65c0573635d2ff8413808c58786efa0f5bcf4f630fc025771f5ec83d66",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mccb95jx_jj5im7fde",
      "key": "swarm-development-hierarchical-1750877313672/type-engineer/branded-types",
      "value": "{\"file_path\":\"/Users/williamsmith/Documents/GitHub/agentic-travel-agent/backend/src/services/auth/functional/types.ts\",\"branded_types\":[\"UserId\",\"SessionId\",\"HashedPassword\",\"AuthToken\",\"RefreshToken\",\"ResetToken\",\"VerificationToken\",\"Email\",\"IPAddress\",\"UserAgent\",\"DeviceFingerprint\",\"Timestamp\"],\"features\":{\"nominal_typing\":\"Using unique symbols for brand declarations\",\"type_guards\":\"is* functions for runtime type checking\",\"validators\":\"validate* functions that throw on invalid input\",\"constructors\":\"create* factory functions for safe type creation\",\"result_type\":\"Ok/Err pattern for functional error handling\",\"utility_functions\":\"Helper functions for common operations\",\"domain_types\":\"AuthUser, AuthSession, AuthTokenPair, etc.\",\"error_types\":\"Discriminated union AuthError type\",\"constants\":\"AUTH_CONSTANTS for configuration\"},\"validation_rules\":{\"UserId\":\"UUID v4 format\",\"SessionId\":\"UUID v4 format\",\"HashedPassword\":\"bcrypt hash format ([aby]$...)\",\"AuthToken\":\"JWT format (header.payload.signature)\",\"RefreshToken\":\"JWT format\",\"ResetToken\":\"64-character hex string\",\"VerificationToken\":\"64-character hex string\",\"Email\":\"RFC-compliant email, normalized to lowercase\",\"IPAddress\":\"IPv4 or IPv6 format\",\"UserAgent\":\"String 1-1000 chars\",\"DeviceFingerprint\":\"String 1-256 chars\",\"Timestamp\":\"ISO 8601 datetime string\"},\"summary\":\"Comprehensive branded type system for AuthService refactoring with 12 branded types, type guards, validators, constructors, Result type for error handling, and domain-specific types using nominal typing patterns for compile-time and runtime type safety.\"}",
      "type": "object",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T18:51:35.133Z",
      "updatedAt": "2025-06-25T18:51:35.133Z",
      "lastAccessedAt": "2025-06-25T18:51:35.133Z",
      "version": 1,
      "size": 1752,
      "compressed": true,
      "checksum": "93cdc9165ca19ce16df2fc1955f20377fee1505d83b40038dde514833dc94242",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mccbi1rm_5mqsv7w4s",
      "key": "sparc_session",
      "value": "Phase 1 implementation complete: Created functional auth module structure with types.ts (branded types: UserId, SessionId, HashedPassword, Email), storage module (password operations), operations.ts (pure functions for register/login/logout), and index.ts (public API). All core modules are implemented and ready for integration. Next step: ensure backward compatibility with existing AuthService class.",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T18:58:30.130Z",
      "updatedAt": "2025-06-25T18:58:30.130Z",
      "lastAccessedAt": "2025-06-25T18:58:30.130Z",
      "version": 1,
      "size": 434,
      "compressed": false,
      "checksum": "63fa153074c23652b702006487f687a61b95bfc21c96d012ac943974facf3c64",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mccbj825_q1z0czyjy",
      "key": "refactor_progress_phase1",
      "value": "SPARC coder successfully created functional auth module structure with: 1) Branded types (UserId, SessionId, etc.) in types/, 2) Storage abstraction in storage/, 3) Pure functions in operations.ts, 4) Public API in index.ts. Files created: types/index.ts, types/core.ts, types/auth.ts, types/errors.ts, types/result.ts, operations.ts, storage/index.ts, storage/interfaces.ts, session/index.ts, index.ts. Next: Create tests and ensure backward compatibility.",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-25T18:59:24.941Z",
      "updatedAt": "2025-06-25T18:59:24.941Z",
      "lastAccessedAt": "2025-06-25T18:59:24.941Z",
      "version": 1,
      "size": 488,
      "compressed": false,
      "checksum": "c862d083d5b83e8d445a5faffb3a1f4e9c2eec5e83561405c76c110974bae68a",
      "references": [],
      "dependencies": []
    }
  ],
  "statistics": {
    "overview": {
      "totalEntries": 16,
      "totalSize": 33867,
      "compressedEntries": 7,
      "compressionRatio": -6.865706806282723,
      "indexSize": 800,
      "memoryUsage": 9874576,
      "diskUsage": 0
    },
    "distribution": {
      "byNamespace": {
        "default": {
          "count": 16,
          "size": 33867
        }
      },
      "byType": {
        "object": {
          "count": 8,
          "size": 11354
        },
        "string": {
          "count": 8,
          "size": 22513
        }
      },
      "byOwner": {
        "system": {
          "count": 16,
          "size": 33867
        }
      },
      "byAccessLevel": {
        "shared": {
          "count": 16,
          "size": 33867
        }
      }
    },
    "temporal": {
      "entriesCreatedLast24h": 16,
      "entriesUpdatedLast24h": 16,
      "entriesAccessedLast24h": 16,
      "oldestEntry": "2025-06-25T02:46:56.023Z",
      "newestEntry": "2025-06-25T18:59:24.941Z"
    },
    "performance": {
      "averageQueryTime": 0,
      "averageWriteTime": 0,
      "cacheHitRatio": 0,
      "indexEfficiency": 0.95
    },
    "health": {
      "expiredEntries": 0,
      "orphanedReferences": 0,
      "duplicateKeys": 0,
      "corruptedEntries": 0,
      "recommendedCleanup": false
    },
    "optimization": {
      "suggestions": [],
      "potentialSavings": {
        "compression": 0,
        "cleanup": 0,
        "deduplication": 0
      },
      "indexOptimization": [
        "Consider periodic index rebuilding for optimal performance"
      ]
    }
  }
}